Simple caclulator app using HTML, CSS, and Javascript.

Explanation for calculateHasRun boolean:

Say we first start using the calculator and have not called calculate() yet, and we have an empty string for currentNumString. Then, say the very first button we push is (. If we had run calculate() since this current set of parenthesis was opened and we were opening another set of parenthesis INSIDE this one (nested parenthesis), then the new, nested set of parenthesis should have a \* put in front of it (if no other operator is explicitly specified). i.e. (4 + 3) (7 - 2) = 35, even though no x is between the two sets of parenthesis. The first set is added to 0 (+0+7) and then the second set is multiplied by the 7. ['+0+7', '+5']. Once the second set of parenthesis closes, the operator put in front of it will be multiplication, making lastParenthesisSolution === \*5.  
However, since calculate() has not yet run for the current set of parenthesis, and we are opening a new set of parenthesis inside WITHOUT specifying an operator (remember, we just hit '(' followed by '(' ), then the equationStack now looks like this: ['+0', '+0'] and that second set of parenthesis should have a '+' in front of it (if no other operator has been explicitly specified) to avoid being multiplied by '+0' once the nested parenthesis close. so for example: ((2 + 2) (3 + 1)). The first ( is hit, and calculateHasRun is set to false on this line of code (it's already set to false at the top of the screen because calculate() has not run yet, and that's what sets it to true). Then, before we calculate anything, we open another set of (. Since calculateHasRun is still set to false, this second set of nested parenthesis gets a + put in front of it. Then we press 2 + and calculate() runs to update the equationStack[lastIndex] to go from '+0' to '+2'. The equationStack now looks like this: ['+0', '+2']. Then we press 2 again, and then close the parenthesis which causes calculate() to run a second time, this time solving for the 2 + 2 and updating the equationStack[lastIndex] to be '+4' before popping the stack and saving that '+4' to lastParenthesisSolution. Now the equationStack looks like this ['+0']. The lastParenthesisSolution is '+4'. But do we need to replace that operator? NO! We want it to be a + in this case, not a \*. This is because we want that '4' to be added to the '+0' at the beginning of the equationString that lives at equationStack[lastIndex] and not multiplied by it. We don't want 2 + 2 to turn into 0 because its sum of 4 was multiplied by the +0. Instead, we want 4 to be added to that +0, and then any SUBSEQUENT set of parenthenthetical math inside that level of parenthetical nesting should be multiplied by 4. So now the lastParenthesisSolution is '+4' and the equationStack is ['+0'] Closing the nested parenthesis doesn't change whether or not calculateHasRun, only opening a new set of parenthesis does that. So calculateHasRun is still set to true, because when we ran 2 + 2 and then closed the parenthesis, we certainly ran the calculate() function, which sets calculateHasRun to true. Now, since calculateHasRun is true, the next set of parenthesis that opens gets a \* put in front of it.
(unless there is a specified operator). Simpler example without nested parenthesis: (9 + 2) (4 + 2) should reduce to 11 \* 6. If the first set of parenthesis gets a \* put in front of it like the second set does, we'd end up with 0 \* 6, which would be wrong.

How handleEquals() works -

we can never have a currentNumString AND a lastParenthesisSolution.
This is because everytime we hit an operator after ), that lastParenthesisSolution is compiled
and set back to an empty string. So if we hit (3 + 4) = we would not have a currentNumString but we would
have a lastParenthesisSolution. If we hit (3 + 4) \* 4 = we would not have a lastParenthesisSolution but we would have a currentNumString.

However, we COULD have a currentNumString AND parenthesis that were left open. If this is the case, then currentNumString should be handled inside handleCloseParenthesis()

These 3 steps handle parenthesis when equals is pushed:

1. check to see if lastParenthesisSolution. If so, that has to be sent into calculate() along with whatever is at equationStack[lastIndex]. once the stack has been updated to include the lastParenthesisSolution (if it exists), set lastParenthesisSolution = '' because in the next step, we're going to call handleCloseParenthesis() which will check to see if there's a lastParenthesisSolution and we don't want to aggregate something twice

2. Next, we need to check to see if there are any other sets of parenthesis that have not yet closed before = was hit. To do this, check the length of the global equationStack, since a new string is pushed for every new set of parenthesis opened. If there are open parenthesis, Inside the loop, keep calling closeParenthesis(), which will pop the equationStack as well as the operatorStack each time it runs, stopping this while loop from running forever. handleCloseParenthesis() will call calculate() with whatever the last solution of parenthetical math was last saved as lastParenthesisSolution. Each time, lastParenthesisSolution is set as the currentNumString and whatever the last equationString is from the stack is passed into calculate().

3. Since handleCloseParenthesis() will set the last set of parenthetical math to lastParenthesisSolution, we need to check for one lastParenthesisSolution after the loop on step 2 runs. To do that, call calculate(lastParenthesisSolution, grabLastStringFromStack(equationStack) <-- this will be equationStack[0], lastParenthesisSolution[0] <-- this is currentOperator, '=' <-- nextOperator )

We do need to be concerned with currentNumString if all parenthesis have been closed. If there are
no parenthesis at all, we can just calculate() the currentNumString against equationStack[0]

But after we handle potential parenthesis, we still have to solve for math that is not parenthetical. What if we just have 2 + 2 = ??? If we have math left over after parenthesis, or math that exists without any parenthesis, it would certainly only exist at equationStack[0]. This is because any set of parenthesis that's opened causes a new string to be pushed to equationStack. So, we'd have to call calculate() with whatever numString was passed into handleEquals() against equationStack[0], which is what we're doing when we call handleOperators() unless there are open parenthesis.
